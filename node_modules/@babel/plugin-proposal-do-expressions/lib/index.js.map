{"version":3,"names":["_helperPluginUtils","require","_utils","_default","exports","default","declare","api","_api$assumption","assertVersion","types","t","noDocumentAll","assumption","name","manipulateOptions","_","parser","plugins","push","visitor","DoExpression","exit","path","node","async","transformDoExpression","doExprPath","doAncestors","WeakSet","add","isFunction","body","get","isArrowFunctionExpression","isExpression","has","replaceWith","blockStatement","returnStatement","flattenStatement","foundDoExpression","deferredPatterns","deferredTemps","param","actualParam","isRestElement","isTSParameterProperty","isLValSideEffectFree","pattern","uid","scope","generateUidIdentifier","cloneNode","length","blockBody","isBlockStatement","unshiftContainer","variableDeclaration","variableDeclarator","arrayPattern","arrayExpression","isStatement","parentPath","Error","type","statements","decl","init","id","flattenExpression","flattenLVal","kind","replaceWithMultiple","test","ifStatement","unaryExpression","breakStatement","remove","update","discardResult","set","initNode","expressionStatement","newPath","left","generateDeclaredUidIdentifier","isVariableDeclaration","buildCodeFrameError","newBody","right","booleanLiteral","insertBefore","flattenByTraverse","opts","isTopLevelCopyable","flattenTrailing","hasDoExpression","isDoExpression","completions","getCompletionRecords","filter","completion","isExpressionStatement","assignmentExpression","expression","buildUndefinedNode","isAssignmentExpression","operator","isLogicalExpression","binaryExpression","nullLiteral","logicalExpression","isConditionalExpression","alternate","consequent","conditionalExpression","isOptionalMemberExpression","computed","object","property","buildOptionalChainChecker","memberExpression","isOptionalCallExpression","callee","calleeStatements","callExpression","arguments","callStatements","flattenCallExpression","isCallExpression","intoTempVariable","thisArgument","isMemberExpression","isSuper","arg","isSpreadElement","spreadElement","identifier","thisExpression","wrapDoExpressionInIIFE","elements","element","restElement","expressions","traverse","Statement","skip","Expression","lastDoExpression","pop","statement","isPureish","isBinaryExpression","isParenthesizedExpression","isSequenceExpression","isUnaryExpression","isIdentifier","isAssignmentPattern"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t, NodePath } from \"@babel/core\";\nimport { wrapDoExpressionInIIFE } from \"./utils.ts\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const { types: t } = api;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? false;\n\n  return {\n    name: \"proposal-do-expressions\",\n    manipulateOptions: (_, parser) => parser.plugins.push(\"doExpressions\"),\n\n    visitor: {\n      DoExpression: {\n        exit(path) {\n          if (path.node.async) {\n            // Async do expressions are not yet supported\n            return;\n          }\n          transformDoExpression(path);\n        },\n      },\n    },\n  };\n\n  function transformDoExpression(doExprPath: NodePath<t.DoExpression>) {\n    const doAncestors = new WeakSet<t.Node>();\n    let path: NodePath = doExprPath;\n    while (path) {\n      if (!path.node) return; // This node has been removed due to previous transformation\n      doAncestors.add(path.node);\n      if (path.isFunction()) {\n        let body = path.get(\"body\");\n        if (path.isArrowFunctionExpression()) {\n          // Do expression within parameters declarations OR expression body\n          if (body.isExpression() && doAncestors.has(body.node)) {\n            [body] = body.replaceWith(\n              t.blockStatement([t.returnStatement(body.node)]),\n            );\n            flattenStatement(body.get(\"body\")[0]);\n          }\n        }\n\n        // Do expression within function parameter lists\n        let foundDoExpression = false;\n        const deferredPatterns: t.PatternLike[] = [];\n        const deferredTemps: t.Identifier[] = [];\n        for (const param of path.get(\"params\")) {\n          const actualParam = param.isRestElement()\n            ? param.get(\"argument\")\n            : param.isTSParameterProperty()\n              ? param.get(\"parameter\")\n              : param;\n          foundDoExpression ||= doAncestors.has(actualParam.node);\n          if (foundDoExpression && !isLValSideEffectFree(actualParam)) {\n            const pattern = actualParam.node;\n            const uid = body.scope.generateUidIdentifier(\"do\");\n            actualParam.replaceWith(t.cloneNode(uid));\n            deferredPatterns.push(pattern);\n            deferredTemps.push(uid);\n          }\n        }\n        if (deferredPatterns.length) {\n          let blockBody: NodePath<t.BlockStatement>;\n          if (body.isBlockStatement()) {\n            blockBody = body;\n          } else {\n            [blockBody] = body.replaceWith(\n              t.blockStatement([t.returnStatement(body.node)]),\n            );\n          }\n\n          blockBody.unshiftContainer(\n            \"body\",\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(\n                t.arrayPattern(deferredPatterns),\n                t.arrayExpression(deferredTemps),\n              ),\n            ]),\n          );\n          flattenStatement(blockBody.get(\"body\")[0]);\n        }\n        return;\n      }\n      if (path.isStatement()) {\n        // Flatten the closest parent statement\n        flattenStatement(path);\n        return;\n      }\n      path = path.parentPath;\n    }\n    throw new Error(\n      \"Internal error: DoExpression must be in a statement. This is a Babel bug, please report it.\",\n    );\n\n    function flattenStatement(path: NodePath<t.Statement>) {\n      switch (path.type) {\n        case \"VariableDeclaration\": {\n          const statements: t.Statement[] = [];\n          for (const decl of path.get(\"declarations\")) {\n            const init = decl.get(\"init\");\n            const id = decl.get(\"id\");\n            if (doAncestors.has(init.node)) {\n              statements.push(...flattenExpression(init));\n            }\n            if (doAncestors.has(id.node)) {\n              statements.push(...flattenLVal(id, init.node, path.node.kind));\n            } else {\n              statements.push(\n                t.variableDeclaration(path.node.kind, [decl.node]),\n              );\n            }\n          }\n          path.replaceWithMultiple(statements);\n          break;\n        }\n        case \"ForStatement\": {\n          // Example:       for (var i = do { f1(); }; do { f2(); }; do { f3(); }) { ... }\n          // Transform to:  var temp1 = f1();\n          //                for (var i = temp1; ;) {\n          //                  var temp2 = f2();\n          //                  if (!temp2) break;\n          //                  ...\n          //                  f3();\n          //                }\n          const body: t.Statement[] = [];\n          const test = path.get(\"test\");\n          if (doAncestors.has(test.node)) {\n            body.push(\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n            );\n            test.remove();\n          }\n          body.push(path.node.body);\n          const update = path.get(\"update\");\n          if (doAncestors.has(update.node)) {\n            body.push(...flattenExpression(update, { discardResult: true }));\n            update.remove();\n          }\n          path.set(\"body\", t.blockStatement(body));\n\n          // Handle do expression within `init`\n          const init = path.get(\"init\");\n          if (doAncestors.has(init.node)) {\n            const initNode = init.isExpression()\n              ? t.expressionStatement(init.node)\n              : init.node;\n            init.remove();\n            const [newPath] = path.replaceWith(\n              t.blockStatement([initNode, path.node]),\n            );\n            flattenStatement(newPath.get(\"body\")[0]);\n          }\n          break;\n        }\n        case \"ForInStatement\":\n        case \"ForOfStatement\": {\n          // Example:       for (const i in do { f1(); }) { ... }\n          // Transform to:  var temp1 = f1();\n          //                for (var temp2 in temp1) {\n          //                  const i = temp2;\n          //                  ...\n          //                }\n\n          // Handle left side\n          const left = path.get(\"left\");\n          if (doAncestors.has(left.node)) {\n            const body = path.get(\"body\");\n            const uid = body.scope.generateDeclaredUidIdentifier(\"do\");\n            if (left.isVariableDeclaration()) {\n              const init = left.get(\"declarations\")[0].get(\"init\");\n              if (init.node) {\n                throw init.buildCodeFrameError(\n                  \"Complex variable declaration in for-in with do expression is not currently supported\",\n                );\n              }\n              init.replaceWith(t.cloneNode(uid));\n              const [newBody] = body.replaceWith(\n                t.blockStatement([left.node, body.node]),\n              );\n              flattenStatement(newBody.get(\"body\")[0]);\n            } else {\n              body.replaceWith(\n                t.blockStatement([\n                  ...flattenLVal(left, t.cloneNode(uid), null),\n                  body.node,\n                ]),\n              );\n            }\n            left.replaceWith(uid);\n          }\n\n          // Handle right side\n          const right = path.get(\"right\");\n          if (doAncestors.has(right.node)) {\n            path.replaceWithMultiple([...flattenExpression(right), path.node]);\n          }\n          break;\n        }\n        case \"WhileStatement\": {\n          // Example:      while (do { foo(); }) { ... }\n          // Transform to: while (true) { var temp = foo(); if (!temp) break; ... }\n          const test = path.get(\"test\");\n          path.set(\n            \"body\",\n            t.blockStatement([\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n              path.node.body,\n            ]),\n          );\n          test.replaceWith(t.booleanLiteral(true));\n          break;\n        }\n        case \"DoWhileStatement\": {\n          // Example:      do { ... } while (do { foo(); })\n          // Transform to: do { ...; var temp = foo(); if (!temp) break; } while (true)\n          const test = path.get(\"test\");\n          path.set(\n            \"body\",\n            t.blockStatement([\n              path.node.body,\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n            ]),\n          );\n          test.replaceWith(t.booleanLiteral(true));\n          break;\n        }\n        case \"ExpressionStatement\":\n          path.replaceWithMultiple(\n            flattenExpression(path.get(\"expression\"), { discardResult: true }),\n          );\n          break;\n        default:\n          path.insertBefore(flattenByTraverse(path));\n      }\n    }\n\n    function flattenExpression(\n      path: NodePath<t.Expression>,\n      opts: {\n        flattenTrailing?: boolean;\n        discardResult?: boolean;\n      } = {},\n    ): t.Statement[] {\n      if (isTopLevelCopyable(path)) {\n        return flattenByTraverse(path, opts.flattenTrailing);\n      }\n      const hasDoExpression = doAncestors.has(path.node);\n      if (hasDoExpression) {\n        if (path.isDoExpression()) {\n          const body = path.get(\"body\");\n          if (!opts.discardResult) {\n            const completions = body\n              .getCompletionRecords(/* shouldPreserveBreak */ true)\n              .filter(completion => completion.isExpressionStatement());\n            if (completions.length) {\n              const uid = body.scope.generateDeclaredUidIdentifier(\"do\");\n              for (const completion of completions) {\n                completion.replaceWith(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(uid),\n                    completion.node.expression,\n                  ),\n                );\n              }\n              path.replaceWith(uid);\n            } else {\n              path.replaceWith(path.scope.buildUndefinedNode());\n            }\n          }\n          return [body.node];\n        } else if (path.isAssignmentExpression()) {\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          if (doAncestors.has(left.node)) {\n            if (path.node.operator !== \"=\") {\n              throw path.buildCodeFrameError(\n                \"Do expression inside complex assignment expression is not currently supported\",\n              );\n            }\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            path.replaceWith(uid);\n            return [\n              ...flattenExpression(right),\n              ...flattenLVal(left, right.node, null),\n            ];\n          }\n        } else if (path.isLogicalExpression()) {\n          const operator = path.node.operator;\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          const statements = [\n            ...flattenExpression(left),\n            t.ifStatement(\n              operator === \"&&\"\n                ? t.cloneNode(left.node)\n                : operator === \"||\"\n                  ? t.unaryExpression(\"!\", t.cloneNode(left.node))\n                  : t.binaryExpression(\n                      \"==\",\n                      t.cloneNode(left.node),\n                      t.nullLiteral(),\n                    ),\n              t.blockStatement(flattenExpression(right)),\n            ),\n          ];\n          path.replaceWith(\n            t.logicalExpression(path.node.operator, left.node, right.node),\n          );\n          return statements;\n        } else if (path.isConditionalExpression()) {\n          const test = path.get(\"test\");\n          const alternate = path.get(\"alternate\");\n          const consequent = path.get(\"consequent\");\n          const statements = [\n            ...flattenExpression(test),\n            t.ifStatement(\n              t.cloneNode(test.node),\n              t.blockStatement(flattenExpression(consequent)),\n              t.blockStatement(flattenExpression(alternate)),\n            ),\n          ];\n          path.replaceWith(\n            t.conditionalExpression(test.node, consequent.node, alternate.node),\n          );\n          return statements;\n        } else if (path.isOptionalMemberExpression() && path.node.computed) {\n          const object = path.get(\"object\");\n          const property = path.get(\"property\");\n          const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n          path.replaceWith(uid);\n          return [\n            ...flattenExpression(object),\n            t.ifStatement(\n              buildOptionalChainChecker(object.node),\n              t.blockStatement([\n                ...flattenExpression(property),\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(uid),\n                    t.memberExpression(\n                      object.node,\n                      property.node,\n                      true /* computed */,\n                    ),\n                  ),\n                ),\n              ]),\n            ),\n          ];\n        } else if (path.isOptionalCallExpression()) {\n          const callee = path.get(\"callee\");\n          const calleeStatements = flattenExpression(callee);\n          const [newPath] = path.replaceWith(\n            t.callExpression(t.cloneNode(callee.node), path.node.arguments),\n          );\n          const callStatements = flattenCallExpression(\n            newPath,\n            opts.discardResult,\n          );\n          return [\n            ...calleeStatements,\n            t.ifStatement(\n              buildOptionalChainChecker(callee.node),\n              t.blockStatement(callStatements),\n            ),\n          ];\n        } else if (path.isCallExpression()) {\n          return flattenCallExpression(path, opts.discardResult);\n        }\n      }\n\n      if (hasDoExpression) {\n        return [\n          ...flattenByTraverse(path, opts.flattenTrailing),\n          intoTempVariable(path, opts.discardResult),\n        ];\n      } else {\n        return [intoTempVariable(path, opts.discardResult)];\n      }\n    }\n\n    function flattenCallExpression(\n      path: NodePath<t.CallExpression>,\n      discardResult?: boolean,\n    ): t.Statement[] {\n      const callee = path.get(\"callee\");\n      let thisArgument: NodePath<t.Expression | t.Super> | undefined;\n      const statements = [];\n      if (callee.isMemberExpression()) {\n        thisArgument = callee.get(\"object\");\n        if (!thisArgument.isSuper()) {\n          statements.push(...flattenExpression(thisArgument));\n        }\n      }\n      statements.push(...flattenExpression(callee as NodePath<t.Expression>));\n\n      for (const arg of path.get(\"arguments\")) {\n        if (arg.isSpreadElement()) {\n          const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n          statements.push(\n            ...flattenExpression(arg.get(\"argument\")),\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.cloneNode(uid),\n                t.arrayExpression([arg.node]),\n              ),\n            ),\n          );\n          arg.replaceWith(t.spreadElement(uid));\n        } else {\n          statements.push(...flattenExpression(arg as NodePath<t.Expression>));\n        }\n      }\n\n      if (thisArgument) {\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(\n              path.node.callee as t.Expression,\n              t.identifier(\"call\"),\n            ),\n            [\n              thisArgument.isSuper()\n                ? t.thisExpression()\n                : t.cloneNode(thisArgument.node),\n              ...(path.node.arguments as Array<t.Expression | t.SpreadElement>),\n            ],\n          ),\n        );\n        return [...statements, intoTempVariable(path, discardResult)];\n      } else {\n        path.replaceWith(t.callExpression(callee.node, path.node.arguments));\n      }\n      return [...statements, intoTempVariable(path, discardResult)];\n    }\n\n    function flattenLVal(\n      path: NodePath<t.LVal | t.PatternLike>,\n      init: t.Expression | null | undefined,\n      declare: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\" | null,\n    ): t.Statement[] {\n      switch (path.type) {\n        case \"ObjectPattern\": {\n          wrapDoExpressionInIIFE(path);\n          // Fallthrough\n        }\n        case \"Identifier\": {\n          if (declare) {\n            return [\n              t.variableDeclaration(declare, [\n                t.variableDeclarator(path.node, init),\n              ]),\n            ];\n          } else {\n            return [\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", path.node, init),\n              ),\n            ];\n          }\n        }\n        case \"MemberExpression\": {\n          return [\n            ...flattenByTraverse(path),\n            t.expressionStatement(t.assignmentExpression(\"=\", path.node, init)),\n          ];\n        }\n        case \"AssignmentPattern\": {\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          if (init) {\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            return [\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", t.cloneNode(uid), init),\n              ),\n              t.ifStatement(\n                t.binaryExpression(\n                  \"===\",\n                  t.cloneNode(uid),\n                  t.buildUndefinedNode(),\n                ),\n                t.blockStatement([\n                  ...flattenExpression(right),\n                  t.expressionStatement(\n                    t.assignmentExpression(\"=\", t.cloneNode(uid), right.node),\n                  ),\n                ]),\n              ),\n              ...flattenLVal(left, uid, declare),\n            ];\n          } else {\n            return flattenLVal(path.get(\"left\"), right.node, declare);\n          }\n        }\n        case \"ArrayPattern\": {\n          const elements: t.ArrayPattern[\"elements\"] = [];\n          const statements: t.Statement[] = [];\n          for (const element of path.get(\"elements\")) {\n            if (!element.type || isLValSideEffectFree(element)) {\n              elements.push(element.node);\n              continue;\n            }\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            if (element.isRestElement()) {\n              elements.push(t.restElement(t.cloneNode(uid)));\n              statements.push(\n                ...flattenLVal(element.get(\"argument\"), uid, declare),\n              );\n            } else {\n              elements.push(t.cloneNode(uid));\n              statements.push(...flattenLVal(element, uid, declare));\n            }\n          }\n          return [\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", t.arrayPattern(elements), init),\n            ),\n            ...statements,\n          ];\n        }\n        default: {\n          throw path.buildCodeFrameError(\n            `Do expression inside ${path.type} is not currently supported`,\n          );\n        }\n      }\n    }\n\n    function flattenByTraverse(\n      path: NodePath,\n      flattenTrailing?: boolean,\n    ): t.Statement[] {\n      // Collect immediate descendant expressions\n      const expressions: NodePath<t.Expression>[] = [];\n      path.traverse({\n        Statement(path) {\n          path.skip();\n        },\n        Expression(path) {\n          expressions.push(path);\n          path.skip();\n        },\n      });\n\n      // Skip flattening trailing expressions that are after all the DoExpressions\n      let lastDoExpression: NodePath<t.Expression>;\n      if (!flattenTrailing) {\n        while (expressions.length) {\n          const path = expressions.pop();\n          if (doAncestors.has(path.node)) {\n            lastDoExpression = path;\n            break;\n          }\n        }\n      }\n\n      // Flatten the expressions\n      const statements: t.Statement[] = [];\n      for (const path of expressions) {\n        statements.push(...flattenExpression(path, { flattenTrailing: true }));\n      }\n      if (lastDoExpression) {\n        statements.push(...flattenExpression(lastDoExpression));\n      }\n      return statements;\n    }\n\n    function intoTempVariable(\n      path: NodePath<t.Expression>,\n      discardResult?: boolean,\n    ): t.Statement {\n      if (discardResult) {\n        return t.expressionStatement(path.node);\n      } else {\n        const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n        const statement = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(uid), path.node),\n        );\n        path.replaceWith(uid);\n        return statement;\n      }\n    }\n  }\n\n  function buildOptionalChainChecker(node: t.Expression) {\n    if (noDocumentAll) {\n      return t.binaryExpression(\"!=\", t.cloneNode(node), t.nullLiteral());\n    } else {\n      return t.logicalExpression(\n        \"&&\",\n        t.binaryExpression(\"!==\", t.cloneNode(node), t.nullLiteral()),\n        t.binaryExpression(\"!==\", t.cloneNode(node), t.buildUndefinedNode()),\n      );\n    }\n  }\n});\n\nfunction isTopLevelCopyable(path: NodePath<t.Node>): boolean {\n  return (\n    path.isPureish() ||\n    path.isBinaryExpression() ||\n    path.isParenthesizedExpression() ||\n    path.isSequenceExpression() ||\n    (path.isUnaryExpression() &&\n      path.node.operator !== \"throw\" &&\n      path.node.operator !== \"delete\")\n  );\n}\n\nfunction isLValSideEffectFree(path: NodePath<t.Node>): boolean {\n  return (\n    path.isIdentifier() ||\n    (path.isAssignmentPattern() &&\n      isLValSideEffectFree(path.get(\"left\")) &&\n      path.get(\"right\").isPureish()) ||\n    (path.isRestElement() && isLValSideEffectFree(path.get(\"argument\")))\n  );\n}\n"],"mappings":"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","ignoreList":[]}